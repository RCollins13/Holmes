import re
from cluster import Cluster, merge


def ClusterParser(handle):
    for cluster_list in parse_clusters(handle, ''):
        cluster = merge(cluster_list)
        cluster.name = cluster.name.strip('_')
        yield cluster


class TruncatedClusterError(Exception):
    """Incomplete cluster entry"""


def parse_clusters(clusterfile, prefix):
    """
    Return an iterator of lists of Clusters parsed from ReadPairCluster output.

    Arguments:
    clusterfile -- Open File object of a ReadPairCluster output file
    prefix      -- Prefix to use when naming clusters. Generally SAMPLE_VARIANT,
                   e.g. DGAP_dg187_tloc. Clusters will be named prefix_ID,
                   where ID is the numerical ID assigned by ReadPairCluster.
                   If there are multiple orientations in a cluster output by
                   ReadPairCluster, this script will split them into concordant
                   clusters, and the clusters will be identified as
                   prefix_ID.01, prefix_ID.02, etc.

    This function returns an iterator which yields a list of Cluster objects
    for each cluster output by ReadPairCluster. Any cluster found to have reads
    with discordant orientations will be split and a list containing all
    Cluster objects generated by the cluster will be returned. Otherwise, a
    list with a single Cluster object representing the cluster will be returned.
    """

    clusters = []
    line_ex = re.compile(r'^\s*$')

    for line in clusterfile:
        # Blank line denotes end of current cluster.
        # Return all split clusters as Cluster objects
        if line_ex.match(line):
            if clusters:
                numprefix = '%s_%s' % (prefix, clusters[0][0].split()[0])
                if len(clusters) > 1:
                    yield ([Cluster.init_rpc(reads, "%s.%02d" % (numprefix, x + 1))
                           for (x, reads) in enumerate(clusters)])
                else:
                    yield [Cluster.init_rpc(reads, numprefix) for reads in clusters]
            clusters = []

        # Add the current line to our list of clusters
        # Reads in cluster must all be of same orientation,
        # so create new clusters as necessary
        else:
            # Catch truncated lines, usually due to failed chr split
            if len(line.split()) < 17:
                cname = line.split()[0]
                chrom = line.split()[3]
                fname = clusterfile.name
                msg = 'Cluster %s on chromosome %s in %s' % (cname, chrom, fname)
                raise TruncatedClusterError(msg)

            if clusters:
                for reads in clusters:
                    if same_orientation(reads[0], line):
                        reads.append(line.strip())
                        line = ''
                        break
                    # try:
                        # if same_orientation(reads[0], line):
                            # reads.append(line.strip())
                            # line = ''
                            # break
                    # except:
                        # import pdb
                        # pdb.set_trace()
                if line:
                    clusters.append([line.strip()])

            else:
                clusters.append([line.strip()])

    if clusters:
        numprefix = '%s_%s' % (prefix, clusters[0][0].split()[0])
        if len(clusters) > 1:
            yield ([Cluster.init_rpc(reads, "%s.%02d" % (numprefix, x + 1))
                    for (x, reads) in enumerate(clusters)])
            # yield [Cluster.init_rpc(reads, prefix, x + 1) for (x, reads) in enumerate(clusters)]
        else:
            yield [Cluster.init_rpc(reads, numprefix) for reads in clusters]
        # yield [Cluster.init_rpc(reads) for reads in clusters]


def same_orientation(lineA, lineB):
    """Return whether two paired end reads are of the same orientation."""

    # SAM flags
    reverse = 16
    mate_reverse = 32

    flagA = int(lineA.split()[11])
    flagB = int(lineB.split()[11])

    return ((flagA & reverse) == (flagB & reverse) and
            (flagA & mate_reverse) == (flagB & mate_reverse))
