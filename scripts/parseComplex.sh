#!/bin/bash

#################################
#             HOLMES            #
#  The liWGS SV discovery tool  #
#################################

# Copyright (c) 2016 Ryan L. Collins and the laboratory of Michael E. Talkowski
# Contact: Ryan L. Collins <rlcollins@g.harvard.edu>
# Code development credits and citation availble on GitHub

#Complex SV parsing script

#######################
# UNRESOLVED FLAG CODES
#######################
# FLAG # INTERPRETATION
#------#--------------
# Cdel # cnMOPS support found for a del subcluster in at least 1/3 samples
# Cdup # cnMOPS support found for a dup subcluster in at least 1/3 samples
#  U   # Clusters unresolvable by coordinates
#  R   # Local realignment attempted
#  S   # Synonymous clusters; will be suffixed with "_" then the ID of the correct cluster
# Art  # Artifact
#  MM  # One side of each linked breakpoint are completely multiply-mapped (mq=0)
#  NC  # No apparent dosage increase/decrease where expected
#  D   # Samples sharing all clusters in event are less than 50% of all samples in all clusters in event
#  I   # Ignore complex cluster; will be handled by downstream pipelines (e.g. DUP-DUP)
#######################

# Possible Output classifications
# DupInsertion
# ExcisionInsertion
# Duplication
# Unresolved
# DupFlankedInsertion
# SKIP_NonComplex
# SKIP_MissingBPs
# Inversion_FlankingDel3
# Inversion_FlankingDel5


#Read input
linker=$1              #complex linking file, generated by Harrions's complex linking script
events=$2              #two-column tab-delimmed list.  First column: deletion/insertion/inversion/transloc. Second column: path to events.bedpe. Preferrably reclassified with reclassify_output.sh
clusters=$3            #two-column tab-delimmed list.  First column: deletion/insertion/inversion/transloc. Second column: path to clusters.bedpe. Must be filtered using cleanClusters_patch.sh
cnMOPS_dels=$4         #list of cnMOPS del calls per sample.  Format: ID TAB path_to_cnMOPS.del.bed
cnMOPS_dups=$5         #list of cnMOPS dup calls per sample.  Format: ID TAB path_to_cnMOPS.dup.bed
output_dir=$6          #output directory.  Will write to ${output_dir}/transloc.classifications.list
cdist=$7               #clustering distance used in cohort
n_cohort=$8            #number of samples in cohort; used to flag artifacts
params=$9              #params file from Holmes liWGS-SV

#Source params file
. ${params}

#Set other params
module load bedtools/2.22.1
module load blatSrc35
blat=/apps/source/blatSrc35/blatSrc/bin/x86_64-redhat-linux-gnu/blat
TMPDIR=/scratch/miket/rlc47temp/tmp.files
hetchrom=/data/talkowski/rlc47/src/GRCh37_heterochromatin.bed
tbit=/data/talkowski/tools/ref/Ensembl_hgGRCh37_71_reord_bwa07/Ensembl_hgGRCh37_71_ERCC_reord.fa.2bit
del_events=$( fgrep deletion ${events} | cut -f2 )
ins_events=$( fgrep insertion ${events} | cut -f2 )
inv_events=$( fgrep inversion ${events} | cut -f2 )
tloc_events=$( fgrep transloc ${events} | cut -f2 )
del_clusters=$( fgrep deletion ${clusters} | cut -f2 )
ins_clusters=$( fgrep insertion ${clusters} | cut -f2 )
inv_clusters=$( fgrep inversion ${clusters} | cut -f2 )
tloc_clusters=$( fgrep transloc ${clusters} | cut -f2 )
maxdist=$( echo "${cdist}*1.5" | bc | cut -d. -f1 ) #uses 1.5x clustering distance for maximum junciton spans due to quartile reporting
##TMPFILES BELOW HERE##
POOL=`mktemp`
TMPCLST=`mktemp`
delcnMOPS_all=`mktemp`
dupcnMOPS_all=`mktemp`
samps=`mktemp`
newpos=`mktemp`
blatres=`mktemp`
preflag=`mktemp`
samps1=`mktemp`
samps2=`mktemp`
ORIENTATIONS=`mktemp`

#Create list of all dels and all dups
while read ID path; do
  awk -v ID=${ID} -v OFS="\t" '{ print $1, $2, $3, ID }' ${path} >> ${delcnMOPS_all}
done < ${cnMOPS_dels}
while read ID path; do
  awk -v ID=${ID} -v OFS="\t" '{ print $1, $2, $3, ID }' ${path} >> ${dupcnMOPS_all}
done < ${cnMOPS_dups}

####################
##Classify DEL-INS##
####################
#Write DEL-INS complex clusters to POOL
awk -v OFS="\t" '{ if (NF==3) print $0 }' ${linker} | fgrep deletion | fgrep insertion > ${POOL}
while read cxID oIDs; do
  delID=$( echo ${oIDs} | sed 's/\ /\n/g' | fgrep deletion )
  insID=$( echo ${oIDs} | sed 's/\ /\n/g' | fgrep insertion )

  #Setup
  cat <( fgrep -w ${delID} ${del_events} | cut -f20 ) <( fgrep -w ${insID} ${ins_events} | cut -f20 ) | tr -d "[]" | sed 's/,/\n/g' | sort | uniq > ${samps}
  delchr=$( fgrep -w ${delID} ${del_events} | cut -f1 )
  delidx=$( echo ${delID} | sed 's/deletion_/\t/g' | cut -f2 )
  awk -v OFS="\t" -v delidx=${delidx} '{ if ($1==delidx) print $0 }' ${del_clusters} > ${TMPCLST}
  #Use closest read with mq>0 as nearest coordinate, if possible
  if [ $( awk '{ if ( ($12==97 || $12==161) && $8>0) print $6 }' ${TMPCLST} | wc -l ) -gt 0 ]; then
    delplus=$( awk '{ if ( ($12==97 || $12==161) && $8>0) print $6 }' ${TMPCLST} | sort -n | tail -n1 ) # perl -e '$d=.75;@l=<>;print $l[int($d*$#l)]' )
  else
    delplus=$( awk '{ if ($12==97 || $12==161) print $6 }' ${TMPCLST} | sort -n | tail -n1 )
  fi
  if [ $( awk '{ if ( ($13==81 || $13==145) && $9>0 ) print $7 }' ${TMPCLST} | wc -l ) -gt 0 ]; then
    delminus=$( awk '{ if ( ($13==81 || $13==145) && $9>0 ) print $7 }' ${TMPCLST} | sort -n | head -n1 ) # perl -e '$d=.25;@l=<>;print $l[int($d*$#l)]' )
  else
    delminus=$( awk '{ if ($13==81 || $13==145) print $7 }' ${TMPCLST} | sort -n | head -n1 )
  fi
  #Get insertion coordinates
  inschr=$( fgrep -w ${insID} ${ins_events} | cut -f1 )
  insidx=$( echo ${insID} | sed 's/insertion_/\t/g' | cut -f2 )
  awk -v OFS="\t" -v insidx=${insidx} '{ if ($1==insidx) print $0 }' ${ins_clusters} > ${TMPCLST}
  #Use closest read with mq>0 as nearest coordinate, if possible
  if [ $( awk '{ if ( ($12==81 || $12==145) && $8>0 ) print $6 }' ${TMPCLST} | wc -l ) -gt 0 ]; then
    insminus=$( awk '{ if ( ($12==81 || $12==145) && $8>0 ) print $6 }' ${TMPCLST} | sort -n | head -n1 ) #perl -e '$d=.25;@l=<>;print $l[int($d*$#l)]' )
  else
    insminus=$( awk '{ if ($12==81 || $12==145) print $6 }' ${TMPCLST} | sort -n | head -n1 )
  fi
  if [ $( awk '{ if ( ($13==97 || $13==161) && $9>0 ) print $7 }' ${TMPCLST} | wc -l ) -gt 0 ]; then
    insplus=$( awk '{ if ( ($13==97 || $13==161) && $9>0 ) print $7 }' ${TMPCLST} | sort -n | tail -n1 ) #perl -e '$d=.75;@l=<>;print $l[int($d*$#l)]' )
  else
    insplus=$( awk '{ if ($13==97 || $13==161) print $7 }' ${TMPCLST} | sort -n | tail -n1 )
  fi
  #Get mapping quality
  delminus_mq=$( echo "$( fgrep -w ${delID} ${del_events} | cut -f13 )*100" | bc | cut -d. -f1 )
  delplus_mq=$( echo "$( fgrep -w ${delID} ${del_events} | cut -f12 )*100" | bc | cut -d. -f1 )
  insminus_mq=$( echo "$( fgrep -w ${insID} ${ins_events} | cut -f12 )*100" | bc | cut -d. -f1 )
  insplus_mq=$( echo "$( fgrep -w ${insID} ${ins_events} | cut -f13 )*100" | bc | cut -d. -f1 )

  #Check for simple insertion from 5'; requires insertion site span to not be > maxdist; doesn't allow mapq=0
  if [ ${insminus} -lt ${delplus} ] && [ ${insplus} -lt ${delminus} ] && [ $( echo "${delminus}-${insplus}" | bc ) -le ${maxdist} ] && [ ${delminus_mq} -gt 0 ] && [ ${delplus_mq} -gt 0 ] && [ ${insminus_mq} -gt 0 ] && [ ${insplus_mq} -gt 0 ]; then
    #check for duplication of insert in at least 10% of samples
    if [ $( echo "$( echo "scale=3;$( bedtools intersect -u -r -f 0.51 -a <( echo -e "${inschr}\t${insminus}\t${delplus}" ) -b <( fgrep -wf ${samps} ${dupcnMOPS_all} ) | wc -l )/$( cat ${samps} | wc -l )" | bc )*1000" | bc | cut -d. -f1 ) -ge 100 ]; then
      echo -e "${delchr}\t${insminus}\t${delplus}\t${inschr}\t${insplus}\t${delminus}\t${cxID}\tDupInsertion\tFLAG:"
    else
      echo -e "${delchr}\t${insminus}\t${delplus}\t${inschr}\t${insplus}\t${delminus}\t${cxID}\tExcisionInsertion\tFLAG:"
    fi

  #Check for simple insertion from 3'; requires insertion site span to not be > maxdist; doesn't allow mapq=0
  elif [ ${insminus} -gt ${delplus} ] && [ ${insplus} -gt ${delminus} ] && [ $( echo "${insminus}-${delplus}" | bc ) -le ${maxdist} ] && [ ${delminus_mq} -gt 0 ] && [ ${delplus_mq} -gt 0 ] && [ ${insminus_mq} -gt 0 ] && [ ${insplus_mq} -gt 0 ]; then
    #check for duplication of insert in at least 10% of samples
    if [ $( echo "$( echo "scale=3;$( bedtools intersect -u -r -f 0.51 -a <( echo -e "${inschr}\t${delminus}\t${insplus}" ) -b <( fgrep -wf ${samps} ${dupcnMOPS_all} ) | wc -l )/$( cat ${samps} | wc -l )" | bc )*1000" | bc | cut -d. -f1 ) -ge 100 ]; then
      echo -e "${delchr}\t${delminus}\t${insplus}\t${inschr}\t${delplus}\t${insminus}\t${cxID}\tDupInsertion\tFLAG:"
    else
      echo -e "${delchr}\t${delminus}\t${insplus}\t${inschr}\t${delplus}\t${insminus}\t${cxID}\tExcisionInsertion\tFLAG:"
    fi

  #Remapping protocol if any mq < 9.25 (equivalent to > 3/4 reads in cluster multiply mapped), at most one single mq=0
  elif [[ ${delminus_mq} -lt 925 || ${delplus_mq} -lt 925 || ${insminus_mq} -lt 925 || ${insplus_mq} -lt 925 ]] && [[ $( echo -e "${delminus_mq}\n${delplus_mq}\n${insminus_mq}\n${insplus_mq}" | awk '{ if ($1==0) print $0 }' | wc -l ) -le 1 ]]; then
    lowmq=$( echo -e "${delminus_mq}\tdelm\n${delplus_mq}\tdelp\n${insminus_mq}\tinsm\n${insplus_mq}\tinsp" | sort -nk1,1 | head -n1 | cut -f2 )
    #remap del- if lowest
    if [ ${lowmq} == "delm" ]; then
      #create blat interval Â± 6 clustering distances out on either side
      blatmin=$( echo "${insminus}-(4*${maxdist})" | bc )
      blatmax=$( echo "${insminus}+(4*${maxdist})" | bc )
      #remap del- reads with mq0
      awk -v OFS="\t" -v delidx=${delidx} '{ if ($1==delidx) print $0 }' ${del_clusters} > ${TMPCLST}
      awk -v OFS="\n" '{ if ( ($13==81 || $13==145) && $9==0) print ">"$3, $15 }' ${TMPCLST} > ${TMPDIR}/remap_tmp.fa
      blat -out=pslx -t=dna -q=dna -minScore=23 -minIdentity=99 -maxGap=0 ${tbit}:${inschr}:${blatmin}-${blatmax} ${TMPDIR}/remap_tmp.fa /dev/stdout | fgrep -v Loaded | fgrep -v Searched > ${blatres}
      #get new del- position
      while read rdID; do
        fgrep ${rdID} ${blatres} | awk -v OFS="\t" '{ if ($9=="+") print $14, $16 }' | sed -e 's/\:/\t/g' -e 's/\-/\t/g' | awk -v OFS="\t" '{ print $2+$4 }'
      done < <( fgrep ">" ${TMPDIR}/remap_tmp.fa | tr -d ">" ) > ${newpos}
      if [ $( cat ${newpos} | wc -l ) -gt 0 ]; then
        delminus=$( sort -nk1,1 ${newpos} | perl -e '$d=.25;@l=<>;print $l[int($d*$#l)]' )
        #if del- near ins-, synonymous variant (dup)
        if [ ${delminus} -le $( echo "${insminus}+${maxdist}" | bc ) ] && [ ${delminus} -ge $( echo "${insminus}-${maxdist}" | bc ) ]; then
          #check for cnMOPS dup support of ins, irrespective of size
          if [ $( bedtools intersect -u -r -f 0.51 -a <( echo -e "${inschr}\t${insminus}\t${insplus}" ) -b <( fgrep -wf ${samps} ${dupcnMOPS_all} ) | wc -l ) -ge 1 ]; then
            echo -e "${inschr}\t${insminus}\t${insplus}\tNA\tNA\tNA\t${cxID}\tDuplication\tFLAG:R,S_${insID},Cdup"
          else
            echo -e "${inschr}\t${insminus}\t${insplus}\tNA\tNA\tNA\t${cxID}\tDuplication\tFLAG:R,S_${insID},NC"
          fi
        else
          echo -e "NA\tNA\tNA\tNA\tNA\tNA\t${cxID}\tUnresolved\tFLAG:U,R"
        fi
      else
        echo -e "NA\tNA\tNA\tNA\tNA\tNA\t${cxID}\tUnresolved\tFLAG:U,R"
      fi
    #remap del+ if lowest
    elif [ ${lowmq} == "delp" ]; then
      #create blat interval Â± 6 clustering distances out on either side
      blatmin=$( echo "${insplus}-(4*${maxdist})" | bc )
      blatmax=$( echo "${insplus}+(4*${maxdist})" | bc )
      #remap del+ reads with mq0
      awk -v OFS="\t" -v delidx=${delidx} '{ if ($1==delidx) print $0 }' ${del_clusters} > ${TMPCLST}
      awk -v OFS="\n" '{ if ( ($12==97 || $12==161) && $8==0) print ">"$3, $14 }' ${TMPCLST} > ${TMPDIR}/remap_tmp.fa
      blat -out=pslx -t=dna -q=dna -minScore=23 -minIdentity=99 -maxGap=0 ${tbit}:${inschr}:${blatmin}-${blatmax} ${TMPDIR}/remap_tmp.fa /dev/stdout | fgrep -v Loaded | fgrep -v Searched > ${blatres}
      #get new del+ position
      while read rdID; do
        fgrep ${rdID} ${blatres} | awk -v OFS="\t" '{ if ($9=="+") print $14, $16 }' | sed -e 's/\:/\t/g' -e 's/\-/\t/g' | awk -v OFS="\t" '{ print $2+$4 }'
      done < <( fgrep ">" ${TMPDIR}/remap_tmp.fa | tr -d ">" ) > ${newpos}
      if [ $( cat ${newpos} | wc -l ) -gt 0 ]; then
        delplus=$( sort -nk1,1 ${newpos} | perl -e '$d=.75;@l=<>;print $l[int($d*$#l)]' )
        #if del+ near ins+, synonymous variant (dup)
        if [ ${delplus} -le $( echo "${insplus}+${maxdist}" | bc ) ] && [ ${delplus} -ge $( echo "${insplus}-${maxdist}" | bc ) ]; then
          #check for cnMOPS dup support of ins, irrespective of size
          if [ $( bedtools intersect -u -r -f 0.51 -a <( echo -e "${inschr}\t${insminus}\t${insplus}" ) -b <( fgrep -wf ${samps} ${dupcnMOPS_all} ) | wc -l ) -ge 1 ]; then
            echo -e "${inschr}\t${insminus}\t${insplus}\tNA\tNA\tNA\t${cxID}\tDuplication\tFLAG:R,S_${insID},Cdup"
          else
            echo -e "${inschr}\t${insminus}\t${insplus}\tNA\tNA\tNA\t${cxID}\tDuplication\tFLAG:R,S_${insID},NC"
          fi
        else
          echo -e "${inschr}\t${insminus}\t${insplus}\tNA\tNA\tNA\t${cxID}\tUnresolved\tFLAG:U,R"
        fi
      else
        echo -e "NA\tNA\tNA\tNA\tNA\tNA\t${cxID}\tUnresolved\tFLAG:U,R"
      fi
    #remap ins- if lowest
    elif [ ${lowmq} == "insm" ]; then
      #create blat interval Â± 6 clustering distances out on either side
      blatmin=$( echo "${delminus}-(4*${maxdist})" | bc )
      blatmax=$( echo "${delminus}+(4*${maxdist})" | bc )
      #remap ins- reads with mq0
      awk -v OFS="\t" -v insidx=${insidx} '{ if ($1==insidx) print $0 }' ${ins_clusters} > ${TMPCLST}
      awk -v OFS="\n" '{ if ( ($12==81 || $12==145) && $8==0) print ">"$3, $14 }' ${TMPCLST} > ${TMPDIR}/remap_tmp.fa
      blat -out=pslx -t=dna -q=dna -minScore=23 -minIdentity=99 -maxGap=0 ${tbit}:${inschr}:${blatmin}-${blatmax} ${TMPDIR}/remap_tmp.fa /dev/stdout | fgrep -v Loaded | fgrep -v Searched > ${blatres}
      #get new ins- position
      while read rdID; do
        fgrep ${rdID} ${blatres} | awk -v OFS="\t" '{ if ($9=="+") print $14, $16 }' | sed -e 's/\:/\t/g' -e 's/\-/\t/g' | awk -v OFS="\t" '{ print $2+$4 }'
      done < <( fgrep ">" ${TMPDIR}/remap_tmp.fa | tr -d ">" ) > ${newpos}
      if [ $( cat ${newpos} | wc -l ) -gt 0 ]; then
        insminus=$( sort -nk1,1 ${newpos} | perl -e '$d=.25;@l=<>;print $l[int($d*$#l)]' )
        #if ins- near del-, synonymous variant (del)
        if [ ${insminus} -le $( echo "${delminus}+${maxdist}" | bc ) ] && [ ${insminus} -ge $( echo "${delminus}-${maxdist}" | bc ) ]; then
          #check for cnMOPS dup support of del, irrespective of size
          if [ $( bedtools intersect -u -r -f 0.51 -a <( echo -e "${delchr}\t${delplus}\t${delminus}" ) -b <( fgrep -wf ${samps} ${delcnMOPS_all} ) | wc -l ) -ge 1 ]; then
            echo -e "${delchr}\t${delplus}\t${delminus}\tNA\tNA\tNA\t${cxID}\tDeletion\tFLAG:R,S_${delID},Cdel"
          else
            echo -e "${delchr}\t${delplus}\t${delminus}\tNA\tNA\tNA\t${cxID}\tDeletion\tFLAG:R,S_${delID},NC"
          fi
        else
          echo -e "NA\tNA\tNA\tNA\tNA\tNA\t${cxID}\tUnresolved\tFLAG:U,R"
        fi
      else
        echo -e "NA\tNA\tNA\tNA\tNA\tNA\t${cxID}\tUnresolved\tFLAG:U,R"
      fi
    #remap ins+ if lowest
    elif [ ${lowmq} == "insp" ]; then
      #create blat interval Â± 6 clustering distances out on either side
      blatmin=$( echo "${delplus}-(4*${maxdist})" | bc )
      blatmax=$( echo "${delplus}+(4*${maxdist})" | bc )
      #remap ins+ reads with mq0
      awk -v OFS="\t" -v insidx=${insidx} '{ if ($1==insidx) print $0 }' ${ins_clusters} > ${TMPCLST}
      awk -v OFS="\n" '{ if ( ($13==97 || $13==161) && $9==0) print ">"$3, $15 }' ${TMPCLST} > ${TMPDIR}/remap_tmp.fa
      blat -out=pslx -t=dna -q=dna -minScore=23 -minIdentity=99 -maxGap=0 ${tbit}:${inschr}:${blatmin}-${blatmax} ${TMPDIR}/remap_tmp.fa /dev/stdout | fgrep -v Loaded | fgrep -v Searched > ${blatres}
      #get new ins- position
      while read rdID; do
        fgrep ${rdID} ${blatres} | awk -v OFS="\t" '{ if ($9=="+") print $14, $16 }' | sed -e 's/\:/\t/g' -e 's/\-/\t/g' | awk -v OFS="\t" '{ print $2+$4 }'
      done < <( fgrep ">" ${TMPDIR}/remap_tmp.fa | tr -d ">" ) > ${newpos}
      if [ $( cat ${newpos} | wc -l ) -gt 0 ]; then
        insminus=$( sort -nk1,1 ${newpos} | perl -e '$d=.25;@l=<>;print $l[int($d*$#l)]' )
        #if ins- near del-, synonymous variant (del)
        if [ ${insminus} -le $( echo "${delminus}+${maxdist}" | bc ) ] && [ ${insminus} -ge $( echo "${delminus}-${maxdist}" | bc ) ]; then
          #check for cnMOPS dup support of del, irrespective of size
          if [ $( bedtools intersect -u -r -f 0.51 -a <( echo -e "${delchr}\t${delplus}\t${delminus}" ) -b <( fgrep -wf ${samps} ${delcnMOPS_all} ) | wc -l ) -ge 1 ]; then
            echo -e "${delchr}\t${delplus}\t${delminus}\tNA\tNA\tNA\t${cxID}\tDeletion\tFLAG:R,S_${delID},Cdel"
          else
            echo -e "${delchr}\t${delplus}\t${delminus}\tNA\tNA\tNA\t${cxID}\tDeletion\tFLAG:R,S_${delID},NC"
          fi
        else
          echo -e "NA\tNA\tNA\tNA\tNA\tNA\t${cxID}\tUnresolved\tFLAG:U,R"
        fi
      else
        echo -e "NA\tNA\tNA\tNA\tNA\tNA\t${cxID}\tUnresolved\tFLAG:U,R"
      fi
    fi

  #If failed to be resolved, check for CNV depth concordance in > 1/3 samples
  else
    #check del & dup cnMOPS overlap for putative CNVs if call larger than 50kb
    if [ $( echo "${delminus}-${delplus}" | bc ) -ge 50000 ]; then
      del_ovr=$( echo "$( echo "scale=3;$( bedtools intersect -u -r -f 0.51 -a <( echo -e "${delchr}\t${delplus}\t${delminus}" ) -b <( fgrep -wf ${samps} ${delcnMOPS_all} ) | wc -l )/$( cat ${samps} | wc -l )" | bc )*1000" | bc | cut -d. -f1  )
    else
      del_ovr=0
    fi
    if [ $( echo "${insplus}-${insminus}" | bc ) -ge 50000 ]; then
      ins_ovr=$( echo "$( echo "scale=3;$( bedtools intersect -u -r -f 0.51 -a <( echo -e "${inschr}\t${insminus}\t${insplus}" ) -b <( fgrep -wf ${samps} ${dupcnMOPS_all} ) | wc -l )/$( cat ${samps} | wc -l )" | bc )*1000" | bc | cut -d. -f1 )  
    else
      ins_ovr=0
    fi
    #Print flag code if cnMOPS overlap = T for 1/4 samples
    if [ ${del_ovr} -ge 250 ] && [ ${ins_ovr} -ge 250 ]; then
      echo -e "NA\tNA\tNA\tNA\tNA\tNA\t${cxID}\tCNVNonCpx\tFLAG:Cdel,Cdup"
    elif [ ${del_ovr} -ge 250 ] && [ ${ins_ovr} -lt 250 ]; then
      echo -e "${delchr}\t${delplus}\t${delminus}\tNA\tNA\tNA\t${cxID}\tDuplicationNonCpx\tFLAG:Cdel"
    elif [ ${del_ovr} -lt 250 ] && [ ${ins_ovr} -ge 250 ]; then
      echo -e "${inschr}\t${insminus}\t${insplus}\tNA\tNA\tNA\t${cxID}\tDuplicationNonCpx\tFLAG:Cdup"
    #exclude variants with mq=0 on one side of both clusters
    elif [[ $( echo -e "${delminus_mq}\n${delplus_mq}\n${insminus_mq}\n${insplus_mq}" | awk '{ if ($1==0) print $0 }' | wc -l ) -gt 1 ]]; then
      echo -e "NA\tNA\tNA\tNA\tNA\tNA\t${cxID}\tUnresolved\tFLAG:U,MM"
    #dup-flanked insertion (unlikely resolution without depth support)
    elif [ ${insminus} -lt ${delplus} ] && [ ${delminus} -lt ${insplus} ]; then
      #get DI and ID dup overlap
      DIdup=$( bedtools intersect -wb -r -f 0.51 -a <( echo -e "${inschr}\t${delminus}\t${insplus}" ) -b <( fgrep -wf ${samps} ${dupcnMOPS_all} ) | wc -l )
      IDdup=$( bedtools intersect -wb -r -f 0.51 -a <( echo -e "${inschr}\t${insminus}\t${delplus}" ) -b <( fgrep -wf ${samps} ${dupcnMOPS_all} ) | wc -l )
      if [ ${DIdup} -gt ${IDdup} ]; then
        echo -e "${delchr}\t${insminus}\t${insplus}\t${delchr}\t${insminus}\t${delplus}\t${cxID}\tDupFlankedInsertion\tFLAG:CDup"
      elif [ ${IDdup} -gt ${DIdup} ]; then
        echo -e "${delchr}\t${insminus}\t${insplus}\t${delchr}\t${delminus}\t${insplus}\t${cxID}\tDupFlankedInsertion\tFLAG:CDup"
      else
        #if no dup support, assign most parsimonious arrangement (aka smallest duplication)
        if [ $( echo "${delplus}-${insminus}" | bc ) -lt $( echo "${insplus}-${delminus}" | bc ) ]; then
          echo -e "${delchr}\t${insminus}\t${insplus}\t${delchr}\t${insminus}\t${delplus}\t${cxID}\tDupFlankedInsertion\tFLAG:NC"
        else
          echo -e "${delchr}\t${insminus}\t${insplus}\t${delchr}\t${delminus}\t${insplus}\t${cxID}\tDupFlankedInsertion\tFLAG:NC"
        fi
      fi
    else
      echo -e "NA\tNA\tNA\tNA\tNA\tNA\t${cxID}\tUnresolved\tFLAG:U"
    fi
  fi
done < ${POOL} > ${preflag}
#Append final poly & artifact flags
while read cxID; do
  delID=$( fgrep -w ${cxID} ${POOL} | cut -f2 )
  insID=$( fgrep -w ${cxID} ${POOL} | cut -f3 )
  fgrep -w ${delID} ${del_events} | cut -f20 | tr -d "[]" | sed 's/,/\n/g' > ${samps1}
  fgrep -w ${insID} ${ins_events} | cut -f20 | tr -d "[]" | sed 's/,/\n/g' > ${samps2}
  cat ${samps1} ${samps2} | tr -d "[]" | sed 's/,/\n/g' | sort | uniq > ${samps}
  samp_ovr=$( echo "scale=3;( $( fgrep -wf ${samps1} ${samps2} | wc -l )/$( cat ${samps} | wc -l ) )*100" | bc | awk '{printf("%d\n",$1 + 0.5)}' )
  if [ $( awk -v cxID=${cxID} '{ if ($7==cxID) print $9 }' ${preflag} ) == "FLAG:" ]; then
    if [ $( cat ${samps} | wc -l ) -gt $( echo "${n_cohort}"/2 | bc ) ]; then
      if [ ${samp_ovr} -ge 50 ]; then
        awk -v cxID=${cxID} '{ if ($7==cxID) print $0"Art" }' ${preflag}
      else
        awk -v cxID=${cxID} '{ if ($7==cxID) print $0"D,Art" }' ${preflag}
      fi
    else
      if [ ${samp_ovr} -ge 50 ]; then
        awk -v cxID=${cxID} '{ if ($7==cxID) print $0 }' ${preflag}
      else
        awk -v cxID=${cxID} '{ if ($7==cxID) print $0"D" }' ${preflag}
      fi
    fi
  else
    if [ $( cat ${samps} | wc -l ) -gt $( echo "${n_cohort}"/2 | bc ) ]; then
      if [ ${samp_ovr} -ge 50 ]; then
        awk -v cxID=${cxID} '{ if ($7==cxID) print $0",Art" }' ${preflag}
      else
        awk -v cxID=${cxID} '{ if ($7==cxID) print $0",D,Art" }' ${preflag}
      fi
    else
      if [ ${samp_ovr} -ge 50 ]; then
        awk -v cxID=${cxID} '{ if ($7==cxID) print $0 }' ${preflag}
      else
        awk -v cxID=${cxID} '{ if ($7==cxID) print $0",D" }' ${preflag}
      fi
    fi
  fi
done < <( cut -f7 ${preflag} ) > ${output_dir}/complex_classifications.list

####################
##Classify DEL-DEL##
####################
#Write DEL-DEL complex clusters to POOL
awk -v OFS="\t" '{ if (NF==3) print $0 }' ${linker} | awk '$2 ~ /deletion/ { print $0 }' | awk '$3 ~ /deletion/ { print $0 }' > ${POOL}
while read cxID oIDs; do
  daID=$( echo ${oIDs} | sed 's/\ /\n/g' | head -n1 )
  dbID=$( echo ${oIDs} | sed 's/\ /\n/g' | tail -n1 )

  #Setup
  cat <( fgrep -w ${daID} ${del_events} | cut -f20 ) <( fgrep -w ${dbID} ${del_events} | cut -f20 ) | tr -d "[]" | sed 's/,/\n/g' | sort | uniq > ${samps}
  nsamps=$( cat $samps | wc -l )
  #Get del A coordinates
  dachr=$( fgrep -w ${daID} ${del_events} | cut -f1 )
  daidx=$( echo ${daID} | sed 's/deletion_/\t/g' | cut -f2 )
  awk -v OFS="\t" -v daidx=${daidx} '{ if ($1==daidx) print $0 }' ${del_clusters} > ${TMPCLST}
  #Use closest read with mq>0 as nearest coordinate, if possible
  if [ $( awk '{ if ( ($12==97 || $12==161) && $8>0) print $6 }' ${TMPCLST} | wc -l ) -gt 0 ]; then
    daplus=$( awk '{ if ( ($12==97 || $12==161) && $8>0) print $6 }' ${TMPCLST} | sort -n | tail -n1 ) # perl -e '$d=.75;@l=<>;print $l[int($d*$#l)]' )
  else
    daplus=$( awk '{ if ($12==97 || $12==161) print $6 }' ${TMPCLST} | sort -n | tail -n1 )
  fi
  if [ $( awk '{ if ( ($13==81 || $13==145) && $9>0 ) print $7 }' ${TMPCLST} | wc -l ) -gt 0 ]; then
    daminus=$( awk '{ if ( ($13==81 || $13==145) && $9>0 ) print $7 }' ${TMPCLST} | sort -n | head -n1 ) # perl -e '$d=.25;@l=<>;print $l[int($d*$#l)]' )
  else
    daminus=$( awk '{ if ($13==81 || $13==145) print $7 }' ${TMPCLST} | sort -n | head -n1 )
  fi
  #Get del A coordinates
  dbchr=$( fgrep -w ${dbID} ${del_events} | cut -f1 )
  dbidx=$( echo ${dbID} | sed 's/deletion_/\t/g' | cut -f2 )
  awk -v OFS="\t" -v dbidx=${dbidx} '{ if ($1==dbidx) print $0 }' ${del_clusters} > ${TMPCLST}
  #Use closest read with mq>0 as nearest coordinate, if possible
  if [ $( awk '{ if ( ($12==97 || $12==161) && $8>0) print $6 }' ${TMPCLST} | wc -l ) -gt 0 ]; then
    dbplus=$( awk '{ if ( ($12==97 || $12==161) && $8>0) print $6 }' ${TMPCLST} | sort -n | tail -n1 ) # perl -e '$d=.75;@l=<>;print $l[int($d*$#l)]' )
  else
    dbplus=$( awk '{ if ($12==97 || $12==161) print $6 }' ${TMPCLST} | sort -n | tail -n1 )
  fi
  if [ $( awk '{ if ( ($13==81 || $13==145) && $9>0 ) print $7 }' ${TMPCLST} | wc -l ) -gt 0 ]; then
    dbminus=$( awk '{ if ( ($13==81 || $13==145) && $9>0 ) print $7 }' ${TMPCLST} | sort -n | head -n1 ) # perl -e '$d=.25;@l=<>;print $l[int($d*$#l)]' )
  else
    dbminus=$( awk '{ if ($13==81 || $13==145) print $7 }' ${TMPCLST} | sort -n | head -n1 )
  fi

  #Print out
  echo -e "${dachr}\t${daplus}\t${daminus}\t${dbchr}\t${dbplus}\t${dbminus}\t${cxID}\tSKIP_NonComplex\tFLAG:I"
done < ${POOL} >> ${output_dir}/complex_classifications.list


####################
##Classify DEL-INV##
####################
#Write DEL-INV complex clusters to POOL
awk -v OFS="\t" '{ if (NF==3) print $0 }' ${linker} | fgrep deletion | fgrep inversion > ${POOL}
while read cxID oIDs; do
  delID=$( echo ${oIDs} | sed 's/\ /\n/g' | fgrep deletion )
  invID=$( echo ${oIDs} | sed 's/\ /\n/g' | fgrep inversion )

  #Setup
  cat <( fgrep -w ${delID} ${del_events} | cut -f20 ) <( fgrep -w ${invID} ${inv_events} | cut -f20 ) | tr -d "[]" | sed 's/,/\n/g' | sort | uniq > ${samps}
  nsamps=$( cat $samps | wc -l )
  #Get mapping quality
  delminus_mq=$( echo "$( fgrep -w ${delID} ${del_events} | cut -f13 )*100" | bc | cut -d. -f1 )
  delplus_mq=$( echo "$( fgrep -w ${delID} ${del_events} | cut -f12 )*100" | bc | cut -d. -f1 )
  invminus_mq=$( echo "$( fgrep -w ${invID} ${inv_events} | cut -f12 )*100" | bc | cut -d. -f1 )
  invplus_mq=$( echo "$( fgrep -w ${invID} ${inv_events} | cut -f13 )*100" | bc | cut -d. -f1 )
  #Get del coordinates
  delchr=$( fgrep -w ${delID} ${del_events} | cut -f1 )
  delidx=$( echo ${delID} | sed 's/deletion_/\t/g' | cut -f2 )
  awk -v OFS="\t" -v delidx=${delidx} '{ if ($1==delidx) print $0 }' ${del_clusters} > ${TMPCLST}
  #Use top quartile read with mq>0 as nearest coordinate, if possible
  if [ $( awk '{ if ( ($12==97 || $12==161) && $8>0) print $6 }' ${TMPCLST} | wc -l ) -gt 0 ]; then
    delplus=$( awk '{ if ( ($12==97 || $12==161) && $8>0) print $6 }' ${TMPCLST} | sort -n | perl -e '$d=.75;@l=<>;print $l[int($d*$#l)]' )
  else
    delplus=$( awk '{ if ($12==97 || $12==161) print $6 }' ${TMPCLST} | sort -n | perl -e '$d=.75;@l=<>;print $l[int($d*$#l)]' )
  fi
  if [ $( awk '{ if ( ($13==81 || $13==145) && $9>0 ) print $7 }' ${TMPCLST} | wc -l ) -gt 0 ]; then
    delminus=$( awk '{ if ( ($13==81 || $13==145) && $9>0 ) print $7 }' ${TMPCLST} | sort -n | perl -e '$d=.25;@l=<>;print $l[int($d*$#l)]' )
  else
    delminus=$( awk '{ if ($13==81 || $13==145) print $7 }' ${TMPCLST} | sort -n | perl -e '$d=.25;@l=<>;print $l[int($d*$#l)]' )
  fi

  #Get inv SE or DE
  invsides=$( fgrep -w ${invID} ${inv_events} | awk '{ if ($9==".") print "DE"; else if ($9=="+") print "SE+"; else if ($9=="-") print "SE-" }' )

  #Write SE inversion clusters as unresolved
  if ! [ ${invsides} == "DE" ]; then
    echo -e "${delchr}\tNA\tNA\t${delchr}\tNA\tNA\t${cxID}\tSKIP_MissingBPs\tFLAG:I"
  #Otherwise attempt to classify
  else
    invidx=$( echo ${invID} | sed 's/inversion_/\t/g' | cut -f2 )
    awk -v OFS="\t" -v invidx=${invidx} '{ if ($1==invidx) print $0 }' ${inv_clusters} > ${TMPCLST}
    #get closest coordinates of +/+ break (3rd quartile)
    invpA=$( awk '{ if ($12==129 || $12==65) print $6 }' ${TMPCLST} | sort -n | perl -e '$d=.75;@l=<>;print $l[int($d*$#l)]' )
    invpB=$( awk '{ if ($13==129 || $13==65) print $7 }' ${TMPCLST} | sort -n | perl -e '$d=.75;@l=<>;print $l[int($d*$#l)]' )
    #get closest coordinates of -/- break (1st quartile)
    invmA=$( awk '{ if ($12==113 || $12==177) print $6 }' ${TMPCLST} | sort -n | perl -e '$d=.25;@l=<>;print $l[int($d*$#l)]' )
    invmB=$( awk '{ if ($13==113 || $13==177) print $7 }' ${TMPCLST} | sort -n | perl -e '$d=.25;@l=<>;print $l[int($d*$#l)]' )
    #determine min and max coordinates of +/+ and -/- breaks
    pmin=$( echo -e "${invpA}\n${invpB}" | sort -n | head -n1 )
    pmax=$( echo -e "${invpA}\n${invpB}" | sort -n | tail -n1 )
    mmin=$( echo -e "${invmA}\n${invmB}" | sort -n | head -n1 )
    mmax=$( echo -e "${invmA}\n${invmB}" | sort -n | tail -n1 )

    #If +/+ and -/- clusters straddle del cluster, then small inversion w/flanking del (limited to flanking del â¤ 3*clustering distance)
    if [ ${pmin} -le ${delplus} ] && [ ${pmax} -gt ${delplus} ] && [ ${mmin} -le ${delminus} ] && [ ${mmax} -gt ${pmax} ] && [ $( echo "${pmax}-${delplus}" | bc ) -le $( echo "3*${cdist}" | bc ) ] && [ $( echo "${delminus}-${mmin}" | bc ) -le $( echo "3*${cdist}" | bc ) ]; then
      #3' flanking del
      if [ $( echo "${pmax}-${delplus}" | bc ) -gt $( echo "${delminus}-${mmin}" | bc ) ]; then
        #check for cnMOPS overlap in at least 33% of samples
        delovr=$( bedtools intersect -r -f 0.51 -wo -a <( echo -e "${delchr}\t${delplus}\t${pmax}" ) -b <( fgrep -wf ${samps} ${delcnMOPS_all} | awk -v OFS="\t" '{ print $1, $2, $3 }' ) | wc -l )
        if [ $( echo "(${delovr}/${nsamps})*100" | bc | cut -f1 -d. ) -ge 33 ]; then
          echo -e "${delchr}\t${delplus}\t${pmax}\t${delchr}\t${mmin}\t${delminus}\t${cxID}\tInversion_FlankingDel3\tFLAG:Cdel"
        else
          echo -e "${delchr}\t${delplus}\t${pmax}\t${delchr}\t${mmin}\t${delminus}\t${cxID}\tInversion_FlankingDel3\tFLAG:NC"
        fi
      #else 5' flanking del
      else
        delovr=$( bedtools intersect -r -f 0.51 -wo -a <( echo -e "${delchr}\t${mmin}\t${delminus}" ) -b <( fgrep -wf ${samps} ${delcnMOPS_all} | awk -v OFS="\t" '{ print $1, $2, $3 }' ) | wc -l )
        if [ $( echo "(${delovr}/${nsamps})*100" | bc | cut -f1 -d. ) -ge 33 ]; then
          echo -e "${delchr}\t${delplus}\t${pmax}\t${delchr}\t${mmin}\t${delminus}\t${cxID}\tInversion_FlankingDel5\tFLAG:Cdel"
        else
          echo -e "${delchr}\t${delplus}\t${pmax}\t${delchr}\t${mmin}\t${delminus}\t${cxID}\tInversion_FlankingDel5\tFLAG:NC"
        fi
      fi

    #3' Proximate deletion check - Noncomplex
    elif [ ${delminus} -lt ${pmin} ] && [ ${delminus} -lt ${mmin} ]; then
      #check for cnMOPS overlap in at least 33% of samples
      delovr=$( bedtools intersect -r -f 0.51 -wo -a <( echo -e "${delchr}\t${delplus}\t${delminus}" ) -b <( fgrep -wf ${samps} ${delcnMOPS_all} | awk -v OFS="\t" '{ print $1, $2, $3 }' ) | wc -l )
      if [ $( echo "(${delovr}/${nsamps})*100" | bc | cut -f1 -d. ) -ge 33 ]; then
        echo -e "${delchr}\t${delplus}\t${pmax}\t${delchr}\tNA\tNA\t${cxID}\tSKIP_NonComplex\tFLAG:I,Cdel"
      else
        echo -e "${delchr}\t${delplus}\t${pmax}\t${delchr}\tNA\tNA\t${cxID}\tSKIP_NonComplex\tFLAG:I,NC"
      fi

    #5' Proximate deletion check - Noncomplex
    elif [ ${delplus} -gt ${pmax} ] && [ ${delplus} -gt ${pmax} ]; then
      #check for cnMOPS overlap in at least 33% of samples
      delovr=$( bedtools intersect -r -f 0.51 -wo -a <( echo -e "${delchr}\t${delplus}\t${delminus}" ) -b <( fgrep -wf ${samps} ${delcnMOPS_all} | awk -v OFS="\t" '{ print $1, $2, $3 }' ) | wc -l )
      if [ $( echo "(${delovr}/${nsamps})*100" | bc | cut -f1 -d. ) -ge 33 ]; then
        echo -e "${delchr}\t${delplus}\t${pmax}\t${delchr}\tNA\tNA\t${cxID}\tSKIP_NonComplex\tFLAG:I,Cdel"
      else
        echo -e "${delchr}\t${delplus}\t${pmax}\t${delchr}\tNA\tNA\t${cxID}\tSKIP_NonComplex\tFLAG:I,NC"
      fi

    #Otherwise unresolved
    else
      echo -e "${delchr}\t${delplus}\t${delminus}\t${delchr}\t${pmin}-${pmax}\t${mmin}-${mmax}\t${cxID}\tUnresolved\tFLAG:U"
    fi
  fi
done < ${POOL} > ${preflag}
#Append final poly & artifact flags
while read cxID; do
  delID=$( fgrep -w ${cxID} ${POOL} | sed 's/\t/\n/g' | fgrep deletion )
  invID=$( fgrep -w ${cxID} ${POOL} | sed 's/\t/\n/g' | fgrep inversion )
  fgrep -w ${delID} ${del_events} | cut -f20 | tr -d "[]" | sed 's/,/\n/g' > ${samps1}
  fgrep -w ${invID} ${inv_events} | cut -f20 | tr -d "[]" | sed 's/,/\n/g' > ${samps2}
  cat ${samps1} ${samps2} | tr -d "[]" | sed 's/,/\n/g' | sort | uniq > ${samps}
  samp_ovr=$( echo "scale=3;( $( fgrep -wf ${samps1} ${samps2} | wc -l )/$( cat ${samps} | wc -l ) )*100" | bc | awk '{printf("%d\n",$1 + 0.5)}' )
  if [ $( awk -v cxID=${cxID} '{ if ($7==cxID) print $9 }' ${preflag} ) == "FLAG:" ]; then
    if [ $( cat ${samps} | wc -l ) -gt $( echo "${n_cohort}"/2 | bc ) ]; then
      if [ ${samp_ovr} -ge 50 ]; then
        awk -v cxID=${cxID} '{ if ($7==cxID) print $0"Art" }' ${preflag}
      else
        awk -v cxID=${cxID} '{ if ($7==cxID) print $0"D,Art" }' ${preflag}
      fi
    else
      if [ ${samp_ovr} -ge 50 ]; then
        awk -v cxID=${cxID} '{ if ($7==cxID) print $0 }' ${preflag}
      else
        awk -v cxID=${cxID} '{ if ($7==cxID) print $0"D" }' ${preflag}
      fi
    fi
  else
    if [ $( cat ${samps} | wc -l ) -gt $( echo "${n_cohort}"/2 | bc ) ]; then
      if [ ${samp_ovr} -ge 50 ]; then
        awk -v cxID=${cxID} '{ if ($7==cxID) print $0",Art" }' ${preflag}
      else
        awk -v cxID=${cxID} '{ if ($7==cxID) print $0",D,Art" }' ${preflag}
      fi
    else
      if [ ${samp_ovr} -ge 50 ]; then
        awk -v cxID=${cxID} '{ if ($7==cxID) print $0 }' ${preflag}
      else
        awk -v cxID=${cxID} '{ if ($7==cxID) print $0",D" }' ${preflag}
      fi
    fi
  fi
done < <( cut -f7 ${preflag} ) >> ${output_dir}/complex_classifications.list


#####################
##Classify DEL-TLOC##
#####################
#Write DEL-TLOC complex clusters to POOL
awk -v OFS="\t" '{ if (NF==3) print $0 }' ${linker} | fgrep deletion | fgrep transloc > ${POOL}
while read cxID oIDs; do
  delID=$( echo ${oIDs} | sed 's/\ /\n/g' | fgrep deletion )
  tlocID=$( echo ${oIDs} | sed 's/\ /\n/g' | fgrep transloc )

  #Setup
  cat <( fgrep -w ${delID} ${del_events} | cut -f20 ) <( fgrep -w ${tlocID} ${tloc_events} | cut -f20 ) | tr -d "[]" | sed 's/,/\n/g' | sort | uniq > ${samps}
  nsamps=$( cat $samps | wc -l )
  #Get mapping quality
  delminus_mq=$( echo "$( fgrep -w ${delID} ${del_events} | cut -f13 )*100" | bc | cut -d. -f1 )
  delplus_mq=$( echo "$( fgrep -w ${delID} ${del_events} | cut -f12 )*100" | bc | cut -d. -f1 )
  tlocA_mq=$( echo "$( fgrep -w ${tlocID} ${tloc_events} | cut -f12 )*100" | bc | cut -d. -f1 )
  tlocB_mq=$( echo "$( fgrep -w ${tlocID} ${tloc_events} | cut -f13 )*100" | bc | cut -d. -f1 )
  #Get del coordinates
  delchr=$( fgrep -w ${delID} ${del_events} | cut -f1 )
  delidx=$( echo ${delID} | sed 's/deletion_/\t/g' | cut -f2 )
  awk -v OFS="\t" -v delidx=${delidx} '{ if ($1==delidx) print $0 }' ${del_clusters} > ${TMPCLST}
  #Use top quartile read with mq>0 as nearest coordinate, if possible
  if [ $( awk '{ if ( ($12==97 || $12==161) && $8>0) print $6 }' ${TMPCLST} | wc -l ) -gt 0 ]; then
    delplus=$( awk '{ if ( ($12==97 || $12==161) && $8>0) print $6 }' ${TMPCLST} | sort -n | perl -e '$d=.75;@l=<>;print $l[int($d*$#l)]' )
  else
    delplus=$( awk '{ if ($12==97 || $12==161) print $6 }' ${TMPCLST} | sort -n | perl -e '$d=.75;@l=<>;print $l[int($d*$#l)]' )
  fi
  if [ $( awk '{ if ( ($13==81 || $13==145) && $9>0 ) print $7 }' ${TMPCLST} | wc -l ) -gt 0 ]; then
    delminus=$( awk '{ if ( ($13==81 || $13==145) && $9>0 ) print $7 }' ${TMPCLST} | sort -n | perl -e '$d=.25;@l=<>;print $l[int($d*$#l)]' )
  else
    delminus=$( awk '{ if ($13==81 || $13==145) print $7 }' ${TMPCLST} | sort -n | perl -e '$d=.25;@l=<>;print $l[int($d*$#l)]' )
  fi
  #Get tloc SE or DE
  tlocsides=$( fgrep -w ${tlocID} ${tloc_events} | awk '{ if ($9==".") print "DE"; else print "SE" }' )

  #Write SE tloc clusters as unresolved
  if ! [ ${tlocsides} == "DE" ]; then
    echo -e "${delchr}\tNA\tNA\t${delchr}\tNA\tNA\t${cxID}\tSKIP_MissingBPs\tFLAG:I"
  else
    #get tloc orientation
    tidx=$( echo "${tlocID}" | sed 's/transloc_/\t/g' | cut -f2 )
    awk -v OFS="\t" -v tidx=${tidx} '{ if ($1==tidx) print $0 }' ${tloc_clusters} > ${TMPCLST}
    #Get dominant pairing
    cut -f12-13 ${TMPCLST} | sed -e 's/\(113\|177\|145\|81\)/M/g' -e 's/\(129\|65\|97\|161\)/P/g' -e 's/\t//g' | sort | uniq -c | awk -v OFS="\t" '{ print $1, $2 }' | sort -nrk1,1 > ${ORIENTATIONS}
    if [ $( fgrep "PM" ${ORIENTATIONS} | wc -l ) -gt 0 ]; then
      PM=$( fgrep "PM" ${ORIENTATIONS} | cut -f1 )
    else
      PM=0
    fi
    if [ $( fgrep "MP" ${ORIENTATIONS} | wc -l ) -gt 0 ]; then
      MP=$( fgrep "MP" ${ORIENTATIONS} | cut -f1 )
    else
      MP=0
    fi
    if [ $( fgrep "PP" ${ORIENTATIONS} | wc -l ) -gt 0 ]; then
      PP=$( fgrep "PP" ${ORIENTATIONS} | cut -f1  )
    else
      PP=0
    fi
    if [ $( fgrep "MM" ${ORIENTATIONS} | wc -l ) -gt 0 ]; then
      MM=$( fgrep "MM" ${ORIENTATIONS} | cut -f1 )
    else
      MM=0
    fi
    ins=$( echo "${PM}+${MP}" | bc )
    inv=$( echo "${PP}+${MM}" | bc )
    #CATEGORIZE INVERSION COORDS
    if [ ${inv} -gt ${ins} ]; then
      #Get chromosomes
      tchrA=$( head -n1 ${TMPCLST} | cut -f4 )
      tchrB=$( head -n1 ${TMPCLST} | cut -f5 )
      #Get +/+ coordinates
      tplusA=$( awk -v tchrA=${tchrA} '{ if ($4==tchrA && ($12==65 || $12==129) ) print $6; else if ($5==tchrA && ($13==65 || $13==129) ) print $7 }' ${TMPCLST} | sort -n | perl -e '$d=.75;@l=<>;print $l[int($d*$#l)]' )
      tplusB=$( awk -v tchrB=${tchrB} '{ if ($4==tchrB && ($12==65 || $12==129) ) print $6; else if ($5==tchrB && ($13==65 || $13==129) ) print $7 }' ${TMPCLST} | sort -n | perl -e '$d=.75;@l=<>;print $l[int($d*$#l)]' )
      #Get -/- coordinates
      tminusA=$( awk -v tchrA=${tchrA} '{ if ($4==tchrA && ($12==113 || $12==177) ) print $6; else if ($5==tchrA && ($13==113 || $13==177) ) print $7 }' ${TMPCLST} | sort -n | perl -e '$d=.25;@l=<>;print $l[int($d*$#l)]' )
      tminusB=$( awk -v tchrB=${tchrB} '{ if ($4==tchrB && ($12==113 || $12==177) ) print $6; else if ($5==tchrB && ($13==113 || $13==177) ) print $7 }' ${TMPCLST} | sort -n | perl -e '$d=.25;@l=<>;print $l[int($d*$#l)]' )
      #Check for excision-insertion
      if [ ${delchr} == ${tchrA} ] && [ ${delplus} -lt ${tplusA} ] && [ ${delminus} -gt ${tminusA} ]; then
        echo -e "${tchrA}\t${tminusA}\t${tplusA}\t${tchrB}\t${tplusB}\t${tminusB}\t${cxID}\tExcisionInvertedInsertion\tFLAG:"
      elif [ ${delchr} == ${tchrB} ] && [ ${delplus} -lt ${tplusB} ] && [ ${delminus} -gt ${tminusB} ]; then
        echo -e "${tchrB}\t${tminusB}\t${tplusB}\t${tchrA}\t${tplusA}\t${tminusA}\t${cxID}\tExcisionInvertedInsertion\tFLAG:"
      #check for 5' proximal deletion
      elif [ ${delchr} == ${tchrA} ] && [ ${delplus} -gt ${tplusA} ] && [ ${delminus} -gt ${tplusA} ]; then
        echo -e "${tchrA}\tNA\tNA\t${tchrB}\tNA\tNA\t${cxID}\tSKIP_NonComplex\tFLAG:I"
      elif [ ${delchr} == ${tchrB} ] && [ ${delplus} -gt ${tplusB} ] && [ ${delminus} -gt ${tplusB} ]; then
        echo -e "${tchrB}\tNA\tNA\t${tchrA}\tNA\tNA\t${cxID}\tSKIP_NonComplex\tFLAG:I"
     #check for 3' proximal deletion
      elif [ ${delchr} == ${tchrA} ] && [ ${delplus} -lt ${tminusA} ] && [ ${delminus} -lt ${tminusA} ]; then
        echo -e "${tchrA}\tNA\tNA\t${tchrB}\tNA\tNA\t${cxID}\tSKIP_NonComplex\tFLAG:I"
      elif [ ${delchr} == ${tchrB} ] && [ ${delplus} -lt ${tminusB} ] && [ ${delminus} -lt ${tminusB} ]; then
        echo -e "${tchrB}\tNA\tNA\t${tchrA}\tNA\tNA\t${cxID}\tSKIP_NonComplex\tFLAG:I"
      else
        echo -e "${tchrA}\tNA\tNA\t${tchrB}\tNA\tNA\t${cxID}\tUnresolved\tFLAG:U"
      fi

    #CATEGORIZE INSERTION COORDS
    else
      #Get chromosomes
      tchrA=$( head -n1 ${TMPCLST} | cut -f4 )
      tchrB=$( head -n1 ${TMPCLST} | cut -f5 )
      #Get A+/- coordinates
      tplusA=$( awk -v tchrA=${tchrA} '{ if ($4==tchrA && ($12==97 || $12==161) ) print $6; else if ($5==tchrA && ($13==97 || $13==161) ) print $7 }' ${TMPCLST} | sort -n | perl -e '$d=.75;@l=<>;print $l[int($d*$#l)]' )
      tminusA=$( awk -v tchrA=${tchrA} '{ if ($4==tchrA && ($12==81 || $12==145) ) print $6; else if ($5==tchrA && ($13==81 || $13==145) ) print $7 }' ${TMPCLST} | sort -n | perl -e '$d=.25;@l=<>;print $l[int($d*$#l)]' )
      #Get B+/- coordinates
      tplusB=$( awk -v tchrB=${tchrB} '{ if ($4==tchrB && ($12==97 || $12==161) ) print $6; else if ($5==tchrB && ($13==97 || $13==161) ) print $7 }' ${TMPCLST} | sort -n | perl -e '$d=.75;@l=<>;print $l[int($d*$#l)]' )
      tminusB=$( awk -v tchrB=${tchrB} '{ if ($4==tchrB && ($12==81 || $12==145) ) print $6; else if ($5==tchrB && ($13==81 || $13==145) ) print $7 }' ${TMPCLST} | sort -n | perl -e '$d=.25;@l=<>;print $l[int($d*$#l)]' )
      #Check for excision-insertion
      if [ ${delchr} == ${tchrA} ] && [ ${delplus} -lt ${tminusA} ] && [ ${delminus} -gt ${tplusA} ]; then
        echo -e "${tchrA}\t${tminusA}\t${tplusA}\t${tchrB}\t${tplusB}\t${tminusB}\t${cxID}\tExcisionInsertion\tFLAG:"
      elif [ ${delchr} == ${tchrB} ] && [ ${delplus} -lt ${tminusB} ] && [ ${delminus} -gt ${tplusB} ]; then
        echo -e "${tchrB}\t${tminusB}\t${tplusB}\t${tchrA}\t${tplusA}\t${tminusA}\t${cxID}\tExcisionInsertion\tFLAG:"
      #check for 5' proximal deletion
      elif [ ${delchr} == ${tchrA} ] && [ ${delplus} -gt ${tplusA} ] && [ ${delminus} -gt ${tplusA} ]; then
        echo -e "${tchrA}\tNA\tNA\t${tchrB}\tNA\tNA\t${cxID}\tSKIP_NonComplex\tFLAG:I"
      elif [ ${delchr} == ${tchrB} ] && [ ${delplus} -gt ${tplusB} ] && [ ${delminus} -gt ${tplusB} ]; then
        echo -e "${tchrB}\tNA\tNA\t${tchrA}\tNA\tNA\t${cxID}\tSKIP_NonComplex\tFLAG:I"
      #check for 3' proximal deletion
      elif [ ${delchr} == ${tchrA} ] && [ ${delplus} -lt ${tminusA} ] && [ ${delminus} -lt ${tminusA} ]; then
        echo -e "${tchrA}\tNA\tNA\t${tchrB}\tNA\tNA\t${cxID}\tSKIP_NonComplex\tFLAG:I"
      elif [ ${delchr} == ${tchrB} ] && [ ${delplus} -lt ${tminusB} ] && [ ${delminus} -lt ${tminusB} ]; then
        echo -e "${tchrB}\tNA\tNA\t${tchrA}\tNA\tNA\t${cxID}\tSKIP_NonComplex\tFLAG:I"
      else
        echo -e "${tchrA}\tNA\tNA\t${tchrB}\tNA\tNA\t${cxID}\tUnresolved\tFLAG:U"
      fi
    fi
  fi
done < ${POOL} > ${preflag}
#Append final poly & artifact flags
while read cxID; do
  delID=$( fgrep -w ${cxID} ${POOL} | sed 's/\t/\n/g' | fgrep deletion )
  tlocID=$( fgrep -w ${cxID} ${POOL} | sed 's/\t/\n/g' | fgrep transloc )
  fgrep -w ${delID} ${del_events} | cut -f20 | tr -d "[]" | sed 's/,/\n/g' > ${samps1}
  fgrep -w ${tlocID} ${tloc_events} | cut -f20 | tr -d "[]" | sed 's/,/\n/g' > ${samps2}
  cat ${samps1} ${samps2} | tr -d "[]" | sed 's/,/\n/g' | sort | uniq > ${samps}
  samp_ovr=$( echo "scale=3;( $( fgrep -wf ${samps1} ${samps2} | wc -l )/$( cat ${samps} | wc -l ) )*100" | bc | awk '{printf("%d\n",$1 + 0.5)}' )
  if [ $( awk -v cxID=${cxID} '{ if ($7==cxID) print $9 }' ${preflag} ) == "FLAG:" ]; then
    if [ $( cat ${samps} | wc -l ) -gt $( echo "${n_cohort}"/2 | bc ) ]; then
      if [ ${samp_ovr} -ge 50 ]; then
        awk -v cxID=${cxID} '{ if ($7==cxID) print $0"Art" }' ${preflag}
      else
        awk -v cxID=${cxID} '{ if ($7==cxID) print $0"D,Art" }' ${preflag}
      fi
    else
      if [ ${samp_ovr} -ge 50 ]; then
        awk -v cxID=${cxID} '{ if ($7==cxID) print $0 }' ${preflag}
      else
        awk -v cxID=${cxID} '{ if ($7==cxID) print $0"D" }' ${preflag}
      fi
    fi
  else
    if [ $( cat ${samps} | wc -l ) -gt $( echo "${n_cohort}"/2 | bc ) ]; then
      if [ ${samp_ovr} -ge 50 ]; then
        awk -v cxID=${cxID} '{ if ($7==cxID) print $0",Art" }' ${preflag}
      else
        awk -v cxID=${cxID} '{ if ($7==cxID) print $0",D,Art" }' ${preflag}
      fi
    else
      if [ ${samp_ovr} -ge 50 ]; then
        awk -v cxID=${cxID} '{ if ($7==cxID) print $0 }' ${preflag}
      else
        awk -v cxID=${cxID} '{ if ($7==cxID) print $0",D" }' ${preflag}
      fi
    fi
  fi
done < <( cut -f7 ${preflag} ) >> ${output_dir}/complex_classifications.list

##FUTURE POSSIBLE ADDITIONS:
# STILL NEED TO COVER MANY COMPLEX CLUSTER SUBGROUPS. THESE COMPRISE MAJORITY OF COMPLEX CLUSTERS, BUT COULD STILL EXTEND SCRIPT FURTHER

#Clean up
rm -rf ${POOL} ${TMPCLST} ${delcnMOPS_all} ${dupcnMOPS_all} ${samps} ${newpos} ${blatres} ${preflag} ${samps1} ${samps2} ${ORIENTATIONS}